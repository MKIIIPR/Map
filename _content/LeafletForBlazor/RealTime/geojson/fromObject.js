import { _computingFeliciaLanguage, _is, _getJSONParametersFromHtmlTag, _replaceTagWithDiv, _replaceTagById, _replaceTagDocumentByTagName } from "../helper/felicia.js"; export let _geojsonLayersGroup = []; let shapesRefract = [], stackHasCharts = []; const __addPointToShapes = (e, o, t) => { null == o ? shapesRefract.push(new t.marker(e.coordinates, { opacity: 1 })) : shapesRefract.push(new t.CircleMarker(e.coordinates, o)) }, __addPointIconToShapes = (e, o, t) => { if (null == o) shapesRefract.push(new t.marker(e.coordinates, { opacity: 1 })); else { let a = new t.icon(o); shapesRefract.push(new t.marker(e.coordinates, { icon: a })) } }, __addPolylineToShapes = (e, o, t) => { null == o ? shapesRefract.push(new t.Polyline(e.coordinates, { opacity: 1 })) : shapesRefract.push(new t.Polyline(e.coordinates, o)) }, __addPolygonToShapes = (e, o, t) => { null == o ? shapesRefract.push(new t.polygon(e.coordinates, { opacity: 1 })) : shapesRefract.push(new t.polygon(e.coordinates, o)) }; export const _addFromGeoJSONObjectArray = (e, o, t, a, l) => { for (var i of (shapesRefract = [], e)) { if (void 0 === i.type && !i.type instanceof String) return; if ("feature" !== i.type.toLowerCase()) return; if (void 0 === i.geometry) return; var n = i.geometry; if (void 0 === n.type && !n.type instanceof String) return; let e = null, r = void 0 === l || void 0 === l.graphic ? null : l.graphic; null === r && (e = void 0 === l || void 0 === l.icon ? null : l.icon); let s = null !== r ? r : e; "point" === n.type.toLowerCase() && void 0 === a ? (null === r && null !== s || (shapesRefract = [...shapesRefract, ..._addPoint(n, s, o, t)]), null !== e && (shapesRefract = [...shapesRefract, ..._addPointIcon(n, s, o, t)])) : "point" === n.type.toLowerCase() && void 0 !== a ? (null !== r && __addPointToShapes(n, s, t), null !== e && __addPointIconToShapes(n, s, t), null === s && (shapesRefract = _addPoint(n, s, o, t))) : "polyline" === n.type.toLowerCase() && void 0 === a ? shapesRefract = [...shapesRefract, ..._addPolyline(n, s, o, t)] : "polyline" === n.type.toLowerCase() && void 0 !== a ? __addPolylineToShapes(n, s, t) : "polygon" === n.type.toLowerCase() && void 0 === a ? shapesRefract = [...shapesRefract, ..._addPolygon(n, s, o, t)] : "polygon" === n.type.toLowerCase() && void 0 !== a && __addPolygonToShapes(n, r, t) } if (0 !== shapesRefract.length) { let e = t.layerGroup(shapesRefract); return e.addTo(o), e.type = a, _geojsonLayersGroup.push(e), { layer: e, name: a, shapes: [] } } }; export const _addFromGeoJSONObjectArrayOnSwitch = (e, o, t, a, l, i) => { shapesRefract = []; let n = void 0 !== t.default ? t.default : null, r = t.cases, s = Object.groupBy(e, (e => e.properties[t.fieldName])); if (Object.keys(s).map((e => ({ type: e, symbol: void 0 === r ? null : r.filter((o => -1 !== Object.keys(o).indexOf(e))).length > 0 ? r.filter((o => -1 !== Object.keys(o).indexOf(e)))[0][e] : n, geometries: s[e] }))).forEach((e => { const o = e.type; let t = e.symbol, a = null; const r = e.geometries; null !== e.symbol && "string" == typeof e.symbol.iconUrl && (a = e.symbol), null !== e.symbol && "string" == typeof e.symbol.radius && (t = e.symbol), t = null !== a ? null : t, r.forEach((e => { const r = e.geometry; "point" === r.type.toLowerCase() && void 0 === o ? (null !== t && (shapesRefract = [...shapesRefract, ..._addPoint(r, n, l, i)]), null !== a && (shapesRefract = [...shapesRefract, ..._addPointIcon(r, n, l, i)])) : "point" === r.type.toLowerCase() && void 0 !== o ? (null !== t && null === a && __addPointToShapes(r, t, i), null !== a && __addPointIconToShapes(r, a, i), null === t && null === a && (shapesRefract = _addPoint(r, n, l, i))) : "polyline" === r.type.toLowerCase() && void 0 === o ? shapesRefract = [...shapesRefract, ..._addPolyline(r, n, l, i)] : "polyline" === r.type.toLowerCase() && void 0 !== o ? __addPolylineToShapes(r, t, i) : "polygon" === r.type.toLowerCase() && void 0 === o ? shapesRefract = [...shapesRefract, ..._addPolygon(r, n, l, i)] : "polygon" === r.type.toLowerCase() && void 0 !== o && __addPolygonToShapes(r, t, i) })) })), 0 !== shapesRefract.length) { let e = i.layerGroup(shapesRefract); return e.addTo(l), e.type = o, _geojsonLayersGroup.push(e), { layer: e, name: o, shapes: shapesRefract } } }; const _toDiv = (e, o, t) => { let a = ""; return a = e.replace(`<${o}`, `<${t}`).replace(`></${o}>`, `></${t}>`), a }; export const _addFromGeoJSONObjectTooltipsFromArray = (e, o, t, a, l, i) => { let n = [0, 0], r = !0, s = 1; if (null == a) return; if (void 0 === a.content) return; void 0 !== a.offset && null !== a.offset && (n = a.offset), void 0 !== a.permanent && null !== a.permanent && (r = a.permanent), void 0 !== a.opacity && null !== a.opacity && (s = a.opacity); let p = []; for (let d of e) { if (void 0 === d.geometry) return; if (void 0 === d.geometry.coordinates) return; if ("point" === d.geometry.type.toLowerCase()) { const e = d.properties; let y = _computingFeliciaLanguage(e, a.content); var c = t.tooltip(d.geometry.coordinates, { content: y, offset: n, permanent: r, opacity: s }).addTo(o.layer); i && _contentToChart(y), c.type = `tooltip_${l}`, p.push(c) } if ("polyline" === d.geometry.type.toLowerCase() || "polygon" === d.geometry.type.toLowerCase()) { const e = d.properties; let y = _computingFeliciaLanguage(e, a.content); (c = t.tooltip(t.polyline(d.geometry.coordinates).getBounds().getCenter(), { content: y, offset: n, permanent: r, opacity: s }).addTo(o.layer)).type = `tooltip_${l}`, p.push(c), i && _contentToChart(y) } } return { visibility: { type: `tooltip_${l}`, visibilityScales: a.visibilityZoomLevels }, tooltips: p } }; const _contentToChart = stringToComputing => { const json = _getJSONParametersFromHtmlTag(stringToComputing, "chart"), htmlConf = _replaceTagWithDiv(stringToComputing, "chart"); _replaceTagById(json.id.replaceAll('"', ""), htmlConf.template); const type = json.type.replaceAll("`", "").replaceAll("'", "").replaceAll('"', ""), data = eval(json.data.replaceAll('"', "")), colorArray = json.render.replaceAll('"', "").replace(/\[(.*?)\]/, "$1").split(",").map((e => e.trim())), labels = json.labels.replace(/\[(.*?)\]/, "$1").split(",").map((e => e.trim())); return new Chart(htmlConf.id, { type: type, data: { labels: labels, datasets: [{ backgroundColor: colorArray, data: data }] }, options: json.options }), htmlConf.template }; export const _addFromGeoJSON = (e, o, t) => _addFromGeoJSONObjectClass(e, o, t); export const _addFromGeoJSONString = (e, o, t, a) => { let l = null; try { l = JSON.parse(e) } catch (e) { console.error("Input file can't be parsed in JSON!"), console.error(e) } if (null !== l) return _addFromGeoJSONObjectClass(l, o, t, a) }; export const _addFromGeoJSONObjectClass = (e, o, t, a) => { let l = null, i = null, n = null, r = null, s = null; if (void 0 === e.name && !e.name instanceof String) return; if (void 0 === e.data && !e.data instanceof Array) return; void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.color && (l = e.symbology), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.color && (l = e.appearance), void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.iconUrl && (i = e.symbology), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.iconUrl && (i = e.appearance), void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.switch && (n = e.symbology.switch), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.switch && (n = e.appearance.switch), void 0 !== e.symbology && null !== e.symbology && void 0 !== e.symbology.visibilityZoomLevels && (r = e.symbology.visibilityZoomLevels), void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.visibilityZoomLevels && (r = e.appearance.visibilityZoomLevels), void 0 !== e.tooltip && null !== e.tooltip && (s = e.tooltip), null === s && void 0 !== e.appearance && null !== e.appearance && void 0 !== e.appearance.tooltip && (s = e.appearance.tooltip); let p = e.data, c = e.name, d = { layer: null, name: "", shapes: [] }; null === n && (d = _addFromGeoJSONObjectArray(p, o, t, c, { graphic: l, icon: i })), null !== n && (d = _addFromGeoJSONObjectArrayOnSwitch(p, e.name, n, r, o, t)); let y = { visibility: { type: "", visibilityScales: {} }, tooltips: !1 }; const u = null !== s && _is(s.content, "chart"); stackHasCharts.push(u), y = _addFromGeoJSONObjectTooltipsFromArray(p, d, t, s, c, u); o.on("tooltipopen", (e => { a && -1 !== stackHasCharts.indexOf(!0) && void 0 !== e && void 0 !== e.tooltip && void 0 !== e.tooltip.options && void 0 !== e.tooltip.options.content && _contentToChart(e.tooltip.options.content) })); let v = [], m = []; null !== l && (v = void 0 !== d ? [d.layer] : [], m = void 0 !== l.visibilityZoomLevels && null !== l.visibilityZoomLevels ? [{ visibilityScales: l.visibilityZoomLevels, type: c }] : []), null !== i && (v = void 0 !== d ? [d.layer] : [], m = void 0 !== i.visibilityZoomLevels && null !== i.visibilityZoomLevels ? [{ visibilityScales: i.visibilityZoomLevels, type: c }] : []), null !== n && (v = void 0 !== d ? [d.layer] : [], m = null === r ? [] : [{ type: c, visibilityScales: r }]); let h = void 0 !== y && void 0 !== y.tooltips && null !== y.tooltip ? y.tooltips : [], f = void 0 !== y && void 0 !== y.visibility && null !== y.visibility ? [y.visibility] : [], g = [...v, ...h], _ = [...m, ...f], b = { layer: null, name: null }; return null != d && (b = { layer: d.layer, name: d.name }), { overlay: b, settings: { shapes: g, visibility: _ } } }; const _addPoint = (e, o, t, a) => { let l = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var i = new a.marker(e.coordinates, { opacity: 1 }); l.push(i), i.addTo(t) } else { i = a.circleMarker(e.coordinates, o); l.push(i), i.addTo(t) } return l } }, _addPointIcon = (e, o, t, a) => { let l = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var i = new a.marker(e.coordinates, { opacity: 1 }); l.push(i), i.addTo(t) } else { let i = new a.icon(o), n = new a.marker(e.coordinates, { icon: i }); l.push(n), n.addTo(t) } return l } }, _addPolyline = (e, o, t, a) => { let l = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var i = new a.Polyline(e.coordinates, { opacity: 1 }); l.push(i), i.addTo(t) } else { i = new a.Polyline(e.coordinates, o); l.push(i), i.addTo(t) } return l } }, _addPolygon = (e, o, t, a) => { let l = []; if (!(void 0 === e.coordinates && !e.coordinates instanceof Array)) { if (null === o) { var i = new a.polygon(e.coordinates, { opacity: 1 }); l.push(i), i.addTo(t) } else { i = new a.polygon(e.coordinates, o); l.push(i), i.addTo(t) } return l } };
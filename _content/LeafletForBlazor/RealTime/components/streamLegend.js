export const createStreamPointLegendForm = t => { const e = t.fontSize, o = t.fontFamily, l = t.fontColor, i = t.fontWeight, n = t.fontStyle, a = document.getElementById(t.canvasId), s = a.getContext("2d"); let c = 0, r = 0; const d = t.paddingLeft, m = t.paddingTop, h = t.paddingRight, y = t.labelPaddingLeft, f = t.displayCounter, u = `${n} ${i} ${e}px ${o}`; s.font = u; let g = m, p = 0; t.items.forEach((t => { let e, o; const l = f ? `${t.type} (${t.guids.length})` : t.type; null !== t.symbol ? (c = Math.max(c, 2 * t.symbol.radius), r = Math.max(r, 2 * t.symbol.radius), e = s.measureText(l).width) : null !== t.icon && (c = Math.max(c, t.icon.iconSize[1]), r = Math.max(r, t.icon.iconSize[0]), o = s.measureText(l).width); const i = void 0 !== e ? e : void 0 !== o ? o : 0; p = Math.max(p, d + c + y + i + h) })), g = (c + 10) * t.items.length + m, a.width = p, a.height = g; let b = m; t.items.forEach(((t, o) => { const i = f ? `${t.type} (${t.guids.length})` : t.type; if (null !== t.symbol) { const e = t.symbol.radius; s.beginPath(), s.arc(d + r / 2, b + c / 2, e, 0, 2 * Math.PI), s.fillStyle = t.symbol.fillColor, s.fill(), s.lineWidth = t.symbol.weight, s.strokeStyle = t.symbol.color, s.stroke(), s.fillStyle = t.symbol.color || "black" } else if (null !== t.icon) { const e = new Image; e.src = t.icon.iconUrl, s.drawImage(e, d, b, t.icon.iconSize[0], t.icon.iconSize[1]) } s.fillStyle = l; const n = b + c / 2 + e / 2.6; s.font = u, s.fillText(i, d + c + y, n), b += c + 10 })) }; var groupBy = (t, e) => t.reduce((function (t, o) { return (t[o[e]] = t[o[e]] || []).push(o), t }), {}), groupsToArray = t => { let e = []; return Object.values(t).forEach((t => { t.forEach((t => { e.push(t) })) })), e };